---
title: "EDA_task"
author: "Evgenii Berdinskikh"
date: "`r Sys.Date()`"
output: 
  html_document:
    keep_md: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  fig.path = "data/pics/figure-"
  )

library(tidyverse)
library(conflicted)
library(skimr)
library(RColorBrewer)
library(rstatix)
library(ggpubr)
library(corrplot)
library(corrr)
library(factoextra)
library(ggsci)
library(pheatmap)
library(ggbiplot)
library(plotly)

conflict_prefer("alpha", "ggplot2")
conflict_prefer("filter", "dplyr")

theme_custom <- theme_bw()+ theme(
    plot.title = element_text(size = 30, hjust = 0.5),
    plot.subtitle = element_text(size = 25, hjust = 0.5),
    strip.text = element_text(size = 20),
    axis.text = element_text(size = 20),
    axis.title = element_text(size = 25),
    legend.title = element_text(size = 25),
    legend.text = element_text(size = 20)
  )

```

## Задание 1

-   Загрузите датасет. Это данные о 671 младенце с очень низкой массой тела (\<1600 грамм), собранные в Duke University Medical Center доктором Майклом О’Ши c 1981 по 1987 г. Описание переменных [здесь](https://hbiostat.org/data/repo/cvlbw). 
-   Переменными исхода являются колонки **dead**, а также **hospstay** - время от рождения до смерти или выписки (выводятся из 'birth' и 'exit', 7 пациентов были выписаны до рождения).
-   Сделайте копию датасета, в которой удалите колонки с количеством пропусков больше 100, а затем удалите все строки с пропусками.

```{r read, include=FALSE}

data_raw <- read_rds("data/raw/very_low_birthweight.RDS")

skim(data_raw)[2:3] %>% 
  arrange(desc(n_missing))

data <- data_raw %>% 
  select(where(~ sum(is.na(.)) <= 100)) %>% 
  # filter(if_any(everything(), is.na))
  drop_na() %>% 
  # Уберем ошибочные данные
  filter(hospstay >= 0)

skim(data)[2:3] %>% 
  arrange(desc(n_missing))

```

## Задание 2

-   Постройте графики плотности распределения для числовых переменных. 
-   Преобразуйте категориальные переменные в факторы. 
-   Удалите выбросы, если таковые имеются. 
-   Для любых двух числовых переменных раскрасьте график по переменной **inout**.

```{r density, fig.height=15, fig.width=15}

# Графики плотности распределения для числовых переменных
data %>% 
  select(where(is.numeric)) %>% 
  mutate(id = row_number()) %>% 
  pivot_longer(-id, names_to = "Переменная", values_to = "Значение") %>% 
  ggplot()+
  geom_density(aes(Значение), fill = "darkturquoise", colour = "black")+
  labs(x = "Значение переменной", 
       y = "Плотность распределения")+
  theme_custom+
  facet_wrap(~Переменная, scales = "free")

# Преобразование данных
cleaned_data <- data %>% 
  transmute(
    birth_date = birth, exit_date = exit, stay_time = hospstay, min_ph = lowph, platelet_n = pltct, race, 
    birth_weight = bwt, gestational_age = gest, inout, 
    multiple_gestation = factor(twn, levels = c(0, 1), labels = c("no", "yes")), delivery, 
    apgar_minute = apg1, ventilation = factor(vent, levels = c(0, 1), labels = c("no", "yes")), 
    pneumothorax = factor(pneumo, levels = c(0, 1), labels = c("no", "yes")), 
    patent_ductus = factor(pda, levels = c(0, 1), labels = c("no", "yes")),  	
    o2_30d = factor(cld, levels = c(0, 1), labels = c("no", "yes")), 
    birth_year = year, sex, dead = factor(dead, levels = c(0, 1), labels = c("no", "yes"))) %>% 
# За выбросы принимаем значения ниже Q1 - 1.5 × IQR и выше Q3 + 1.5 × IQR
  mutate(across(where(is.numeric), 
                ~ case_when(
                  . < quantile(., 0.25, na.rm = TRUE) - 1.5 * IQR(., na.rm = TRUE) | 
                  . > quantile(., 0.75, na.rm = TRUE) + 1.5 * IQR(., na.rm = TRUE) ~ NA,
                  TRUE ~ .
                ))) %>% 
  select(where(~ sum(is.na(.)) <= 100)) %>% 
  # filter(if_any(everything(), is.na))
  drop_na()

       
# Графики плотности распределения по переменной - inout.
cleaned_data %>% 
  select(where(is.numeric), inout) %>% 
  pivot_longer( -inout, names_to = "Переменная", values_to = "Значение") %>% 
  ggplot()+
  geom_density(aes(Значение, fill = inout),  colour = "black", alpha = 0.7)+
  scale_fill_brewer(palette = "Pastel1")+
  labs(x = "Значение переменной", 
       y = "Плотность распределения")+
  theme_custom+
  theme(
    legend.position = "top", 
          )+
  facet_wrap(~Переменная, scales = "free")


```

## Задание 3

- Проведите тест на сравнение значений колонки **min_ph** между группами в переменной **inout**. Вид статистического теста определите самостоятельно. 
- Визуализируйте результат через библиотеку 'rstatix'.

```{r t_test, fig.height=8}

# Критерий Шапиро — Уилка -> t-критерий Стьюдента 
shapiro.test(cleaned_data$min_ph[data$inout == "born at Duke"])
shapiro.test(cleaned_data$min_ph[data$inout == "transported"])
t.test(data = cleaned_data,  min_ph ~ inout) 

# Коробчатая диаграмма + результаты стат. теста
ggplot(cleaned_data)+
  geom_boxplot(aes( x = inout, y = min_ph,  fill = inout))+
  scale_fill_brewer(palette = "Pastel1")+
  scale_y_continuous(limits = c(NA, max(cleaned_data$min_ph) + 0.2))+
  labs(y = "lowest pH in first 4 days of life", x = "")+
  theme_custom +
  theme(legend.position = "none")+
  stat_pvalue_manual(t_test(data = cleaned_data,  min_ph ~ inout),
                     label = "T-test, p = {p}", 
                     size = 10, 
                     y.position = max(cleaned_data$min_ph) + 0.1)
  

```
- Как бы вы интерпретировали результат, если бы знали, что более низкое значение **min_ph** ассоциировано с более низкой выживаемостью?

Для сравнения минимального уровня pH в первые четыре дня жизни ребенка в зависимости от места рождения (в медицинском центре Университета Дьюка или за его пределами) был применен **t-критерий Стьюдента**. Предварительно была проведена проверка распределений на нормальность с использованием **критерия Шапиро—Уилка**. Анализ выявил статистически значимые различия между группами: дети, рожденные в центре Дьюка, в среднем имеют более высокий уровень pH, что может свидетельствовать о лучших шансах на выживание.

## Задание 4

- Сделайте новый датафрейм, в котором оставьте только континуальные или ранговые данные, кроме 'birth', 'year' и 'exit'. - Сделайте корреляционный анализ этих данных. 
- Постройте два любых типа графиков для визуализации корреляций.

```{r cor, fig.width=8}

# Подготовка данных
cor_data <- cleaned_data %>% 
  select(where(is.numeric), -birth_date, -birth_year, -exit_date )

# Матрица корреляций
cor(cor_data) 

# Визуализация корреляций
corrplot(cor(cor_data), method = 'number', type = 'lower', diag = FALSE)

cor(cor_data) %>% 
  network_plot(min_cor = .2)

```

## Задание 5

- Постройте иерархическую кластеризацию на этом датафрейме.

```{r dendrogram, fig.height=25, fig.width=35}

rownames(cor_data) <- paste0("id-", seq(1:nrow(cor_data)))
scaled_cor_data <- scale(cor_data)
dist_cor_data <- dist(scaled_cor_data, method = "euclidean")
hc <- hclust(d = dist_cor_data, method = "ward.D2")

Cluster_full <- fviz_dend(
  hc, k = 4, show_labels = FALSE,  main = "",
  k_colors = "lancet", rect = TRUE, horiz = TRUE, 
)

dend_cuts <- cut(as.dendrogram(hc), h = 17)

Cluster_1 <- fviz_dend(dend_cuts$lower[[1]], 
          main = "Кластер 1", 
          k = 1, k_colors = pal_lancet()(4)[1], 
          cex = 1, label_cols = "black",  
          ggtheme = theme_custom, 
          )
Cluster_2 <- fviz_dend(dend_cuts$lower[[2]], 
          main = "Кластер 2",
          k = 1, k_colors = pal_lancet()(4)[2], 
          cex = 1, label_cols = "black", 
          ggtheme = theme_custom,  
          )
Cluster_3 <- fviz_dend(dend_cuts$lower[[3]], 
          main = "Кластер 3",
          k = 1, k_colors = pal_lancet()(4)[3], 
          cex = 1, label_cols = "black",  
          ggtheme = theme_custom, 
          )
Cluster_4 <- fviz_dend(dend_cuts$lower[[4]], 
          main = "Кластер 4",  
          k = 1, k_colors = pal_lancet()(4)[4], 
          cex = 1, label_cols = "black", 
          ggtheme = theme_custom, 
          )

ggarrange( Cluster_full, 
           ggarrange(Cluster_4, Cluster_3, Cluster_2, Cluster_1, ncol = 1),
           nrow = 1, widths = c(1, 3) )




```

## Задание 6

- Сделайте одновременный график heatmap и иерархической кластеризации. 

```{r pheatmap, fig.height=10, fig.width=15}

pheatmap(scaled_cor_data,
         show_rownames = FALSE, 
         clustering_distance_rows = dist_cor_data,
         clustering_method = "ward.D2", 
         cutree_rows = 4,
         cutree_cols = length(colnames(scaled_cor_data)),
         treeheight_row = 200, 
         angle_col = 45, 
         angle_row = 45, 
         main = "Тепловая карта с дендрограммами строк и столбцов")

```
- Интерпретируйте результат

1. **Цвет** на тепловой карте представляет стандартизованные значения для каждой строки и переменной. Красный и синий цвета указывают на отклонения от среднего значения (красный — положительное отклонение, синий — отрицательное).
2. **Кластеризация по строкам** группирует объекты (пациентов) с похожими характеристиками по переменным. Результаты кластеризации строк согласуются с дендрограммой кластеров, полученной на предыдущем этапе.
3. **Кластеризация по столбцам** объединяет переменные, которые имеют схожие паттерны значений, например: *birth_weight* и *gestational_age*, что соответствует корреляционному анализу.

## Задание 7

- Проведите PCA анализ на этих данных. 

```{r pca, fig.width=10}

scaled_cor_data_pca <- prcomp(scaled_cor_data, scale = FALSE) 
summary(scaled_cor_data_pca)
fviz_eig(scaled_cor_data_pca, addlabels = T, 
         xlab = "", ylab = "Процент дисперсии",
         ggtheme = theme_custom,
         main = "Объясненная дисперсия компонентов PCA")

```

- Проинтерпретируйте результат. Нужно ли применять шкалирование для этих данных перед проведением PCA?

Согласно **Cumulative Proportion**, первые три компоненты объясняют около 75% вариации данных, что является хорошим показателем, так как большая часть информации сохраняется в этих трех компонентах.

Шкалирование данных перед PCA необходимо, чтобы привести все переменные к одному масштабу и избежать доминирования переменных с большими диапазонами значений. Однако для бинарных переменных нормирование может исказить информацию. В нашем случае данные уже предварительно нормированы, и остались только количественные переменные, для которых нормирование полезно.

## Задание 8

- Постройте biplot график для PCA. 
- Раскрасьте его по значению колонки 'dead'.

```{r biplot, fig.height=8, fig.width=8}

ggbiplot(scaled_cor_data_pca, 
         scale=0,
         groups = cleaned_data$dead, 
         point.size	= 2, 
         ellipse = TRUE, ellipse.alpha = 0.2,
         varname.size = 7,
         alpha = 0.7) +
  labs(fill = "Dead", colour = "Dead") +
  scale_color_manual(values = c("yes" = "coral3", "no" = "palegreen3")) +
  scale_fill_manual(values = c("yes" = "coral1", "no" = "palegreen1")) +
  theme_custom+
  theme(legend.direction = 'horizontal', legend.position = 'top')

```

## Задание 9???????????????????????????????????

- Переведите последний график в 'plotly'. При наведении на точку нужно, чтобы отображалось id пациента.

```{r plotly, fig.height=15, fig.width=15}



ggplotly(
ggbiplot(scaled_cor_data_pca, 
         scale=0,
         groups = cleaned_data$dead, 
         ellipse = TRUE, ellipse.alpha = 0.2,
         varname.size = 4, 
         point.size	= 1, alpha = 0.7, 
         labels = rownames(cor_data), 
         labels.size = 0
         ) +
  labs(fill = "Dead", colour = "Dead") +
  scale_color_manual(values = c("yes" = "coral3", "no" = "palegreen3")) +
  scale_fill_manual(values = c("yes" = "coral1", "no" = "palegreen1")) +
  theme_custom,
  tooltip = c("x", "labels")
)

# rownames(cor_data)

```
