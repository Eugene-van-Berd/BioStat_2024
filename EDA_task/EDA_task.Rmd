---
title: "EDA_task"
author: "Evgenii Berdinskikh"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(conflicted)
library(skimr)
library(RColorBrewer)
library(rstatix)
library(ggpubr)
library(corrplot)
library(corrr)

conflict_prefer("alpha", "ggplot2")
conflict_prefer("filter", "dplyr")

theme_custom <- theme_bw()+ theme(
    plot.title = element_text(size = 30, hjust = 0.5),
    plot.subtitle = element_text(size = 25, hjust = 0.5),
    strip.text = element_text(size = 20),
    axis.text = element_text(size = 20),
    axis.title = element_text(size = 25),
    legend.title = element_text(size = 25),
    legend.text = element_text(size = 20)
  )

```

## Задание 1

-   Загрузите датасет. Это данные о 671 младенце с очень низкой массой тела (\<1600 грамм), собранные в Duke University Medical Center доктором Майклом О’Ши c 1981 по 1987 г. Описание переменных [здесь](https://hbiostat.org/data/repo/cvlbw). 
-   Переменными исхода являются колонки **dead**, а также **hospstay** - время от рождения до смерти или выписки (выводятся из 'birth' и 'exit', 7 пациентов были выписаны до рождения).
-   Сделайте копию датасета, в которой удалите колонки с количеством пропусков больше 100, а затем удалите все строки с пропусками.

```{r read}

data_raw <- read_rds("data/raw/very_low_birthweight.RDS")

skim(data_raw)[2:3] %>% 
  arrange(desc(n_missing))

data <- data_raw %>% 
  select(where(~ sum(is.na(.)) <= 100)) %>% 
  # filter(if_any(everything(), is.na))
  drop_na() %>% 
  # Уберем ошибочные данные
  filter(hospstay >= 0)

skim(data)[2:3] %>% 
  arrange(desc(n_missing))

```

## Задание 2

-   Постройте графики плотности распределения для числовых переменных. 
-   Преобразуйте категориальные переменные в факторы. 
-   Удалите выбросы, если таковые имеются. 
-   Для любых двух числовых переменных раскрасьте график по переменной **inout**.

```{r density, fig.height=15, fig.width=15}

# Графики плотности распределения для числовых переменных
data %>% 
  select(where(is.numeric)) %>% 
  mutate(id = row_number()) %>% 
  pivot_longer(-id, names_to = "Переменная", values_to = "Значение") %>% 
  ggplot()+
  geom_density(aes(Значение), fill = "darkturquoise", colour = "black")+
  labs(x = "Значение переменной", 
       y = "Плотность распределения")+
  theme_custom+
  facet_wrap(~Переменная, scales = "free")

# Преобразование данных
cleaned_data <- data %>% 
  transmute(
    birth_date = birth, exit_date = exit, stay_time = hospstay, min_ph = lowph, platelet_n = pltct, race, 
    birth_weight = bwt, gestational_age = gest, inout, 
    multiple_gestation = factor(twn, levels = c(0, 1), labels = c("no", "yes")), delivery, 
    apgar_minute = apg1, ventilation = factor(vent, levels = c(0, 1), labels = c("no", "yes")), 
    pneumothorax = factor(pneumo, levels = c(0, 1), labels = c("no", "yes")), 
    patent_ductus = factor(pda, levels = c(0, 1), labels = c("no", "yes")),  	
    o2_30d = factor(cld, levels = c(0, 1), labels = c("no", "yes")), 
    birth_year = year, sex, dead = factor(dead, levels = c(0, 1), labels = c("no", "yes"))) %>% 
# За выбросы принимаем значения ниже Q1 - 1.5 × IQR и выше Q3 + 1.5 × IQR
  mutate(across(where(is.numeric), 
                ~ case_when(
                  . < quantile(., 0.25, na.rm = TRUE) - 1.5 * IQR(., na.rm = TRUE) | 
                  . > quantile(., 0.75, na.rm = TRUE) + 1.5 * IQR(., na.rm = TRUE) ~ NA,
                  TRUE ~ .
                ))) %>% 
  select(where(~ sum(is.na(.)) <= 100)) %>% 
  # filter(if_any(everything(), is.na))
  drop_na()

       
# Графики плотности распределения по переменной - inout.
cleaned_data %>% 
  select(where(is.numeric), inout) %>% 
  pivot_longer( -inout, names_to = "Переменная", values_to = "Значение") %>% 
  ggplot()+
  geom_density(aes(Значение, fill = inout),  colour = "black", alpha = 0.7)+
  scale_fill_brewer(palette = "Pastel1")+
  labs(x = "Значение переменной", 
       y = "Плотность распределения")+
  theme_custom+
  theme(
    legend.position = "top", 
          )+
  facet_wrap(~Переменная, scales = "free")


```






## Задание 3

- Проведите тест на сравнение значений колонки **min_ph** между группами в переменной **inout**. Вид статистического теста определите самостоятельно. 
- Визуализируйте результат через библиотеку 'rstatix'.

```{r t_test, fig.height=8}

# Критерий Шапиро — Уилка -> t-критерий Стьюдента 
shapiro.test(cleaned_data$min_ph[data$inout == "born at Duke"])
shapiro.test(cleaned_data$min_ph[data$inout == "transported"])
t.test(data = cleaned_data,  min_ph ~ inout) 

# Коробчатая диаграмма + результаты стат. теста
ggplot(cleaned_data)+
  geom_boxplot(aes( x = inout, y = min_ph,  fill = inout))+
  scale_fill_brewer(palette = "Pastel1")+
  scale_y_continuous(limits = c(NA, max(cleaned_data$min_ph) + 0.2))+
  labs(y = "lowest pH in first 4 days of life", x = "")+
  theme_custom +
  theme(legend.position = "none")+
  stat_pvalue_manual(t_test(data = cleaned_data,  min_ph ~ inout),
                     label = "T-test, p = {p}", 
                     size = 10, 
                     y.position = max(cleaned_data$min_ph) + 0.1)
  

```
- Как бы вы интерпретировали результат, если бы знали, что более низкое значение **min_ph** ассоциировано с более низкой выживаемостью?

Для сравнения минимального уровня pH в первые четыре дня жизни ребенка в зависимости от места рождения (в медицинском центре Университета Дьюка или за его пределами) был применен **t-критерий Стьюдента**. Предварительно была проведена проверка распределений на нормальность с использованием **критерия Шапиро—Уилка**. Анализ выявил статистически значимые различия между группами: дети, рожденные в центре Дьюка, в среднем имеют более высокий уровень pH, что может свидетельствовать о лучших шансах на выживание.

## Задание 4

- Сделайте новый датафрейм, в котором оставьте только континуальные или ранговые данные, кроме 'birth', 'year' и 'exit'. - Сделайте корреляционный анализ этих данных. 
- Постройте два любых типа графиков для визуализации корреляций.

```{r cor, fig.width=8}

# Подготовка данных
cor_data <- cleaned_data %>% 
  select(where(is.numeric), -birth_date, -birth_year, -exit_date )

# Матрица корреляций
cor(cor_data) 

# Визуализация корреляций
corrplot(cor(cor_data), method = 'number', type = 'lower', diag = FALSE)

cor(cor_data) %>% 
  network_plot(min_cor = .2)

```

## Задание 5 ----------------------------------------------------------- 

- Постройте иерархическую кластеризацию на этом датафрейме.

```{r}


```

## Задание 6 ?????????????????????????????????????????????????????

- Сделайте одновременный график heatmap и иерархической кластеризации. 
- Интерпретируйте результат.

```{r pheatmap}

library(pheatmap)
scale_cor_data <- scale(cor_data)

pheatmap(scale_cor_data,
         show_rownames = FALSE, 
         clustering_distance_rows = dist(scale_cor_data),
         clustering_method = "ward.D2", 
         cutree_rows = 5,
         cutree_cols = length(colnames(scale_cor_data)),
         angle_col = 45, 
         main = "Dendrograms for clustering rows and columns with heatmap")

```

